# T초 동안 떨어지는 자두, 최대 W번만 움직임 : 이동 횟수에 제한이 있으므로 어느 나무로 이동 하느냐에 따라 먹을 수 있는 자두 개수 최대값이 달라짐
# 매 초마다 이동 / 이동 X 로 나누면 2^1000 (X) => DP 이용
# int[][][] dp = new int[몇번 째 자두가 떨어지는가][자두가 어느 위치에 있냐][이동 횟수]
# 움직이지 않고 같은 위치에서 다음 자두를 받는 경우 VS 움직여서 다른 위치의 자두를 받는 경우(이전에 어느 위치에 있었느냐에 따라 달라짐)
# t번째 자두가 떨어질 때 사람이 1번 위치에 w만큼 이동해서 있는 경우 : max(dp[t-1][1][w(이동 필요 X)], dp[t-1][2][w-1(이동 필요 O)])

T, W = map(int, input().split(" "))  # 1000, 30
arr = [0] + [int(input()) for _ in range(T)]
dp = [[[0 for _ in range(W+1)] for _ in range(3)] for _ in range(T+1)]

for i in range(1, T+1):    # 시간
    for k in range(W+1):     # 이동 횟수(0, 1, 2) : 움직이지 않는 경우도 포함 필요
        if arr[i] == 1:    # 자두가 1번 나무에서 떨어지는 경우
            if k == 0:     # 이동 하지 않는 경우
                dp[i][1][k] = dp[i-1][1][k] + 1
                dp[i][2][k] = dp[i-1][2][k]
            else:
                dp[i][1][k] = max(dp[i-1][1][k] + 1, dp[i-1][2][k-1] + 1)    # i번째 자두가 떨어질 때 사람이 1번 위치에 W 만큼 이동해서 있던 경우
                dp[i][2][k] = max(dp[i-1][1][k-1], dp[i-1][2][k])      # i번째 자두가 떨어질 때 사람이 2번 위치에 W 만큼 이동해서 있던 경우
        else:              # 자두가 2번 나무에서 떨어지는 경우
            if i == 1 and k == 0:  # 시작이 1번 나무이므로 이동하지 않으면서 첫번째 자두는 무조건 먹을 수 X
                continue

            if k == 0:  # 이동 하지 않는 경우
                dp[i][1][k] = dp[i - 1][1][k]
                dp[i][2][k] = dp[i - 1][2][k] + 1    # 무조건 이동 필요(시작 위치가 1번)
            else:
                dp[i][1][k] = max(dp[i-1][1][k], dp[i-1][2][k-1])      # 1번 위치에 있었다면 자두를 먹을 수 없음
                dp[i][2][k] = max(dp[i-1][1][k-1] + 1, dp[i-1][2][k] + 1)  # 2번 위치에 있었다면 자두를 먹을 수 있음

res = 0
for i in range(W+1):     # 이동 횟수
    res = max(dp[T][1][i], dp[T][2][i])
print(res)