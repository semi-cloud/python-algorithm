# 도둑이 홈칠 수 있는 돈의 최댓값 반환
# 처음 생각 : 인접한 집이 안 되니까 홀수번, 짝수번 집 중에 더 많이 털 수 있는 쪽 고르면 되지 않나? => 안됌
# 꼭 i번째 / i+2 / i + 4 번째 집처럼 인접 하지 않은 모든 집을 거치는게 최적의 답이 X

def solution(money):  # 각 집에 있는 돈이 담긴 배열
    N = len(money)
    dp1 = [0 for _ in range(N)]    # 이전 집을 들리면 현재 집을 들리지 못함
    dp2 = [0 for _ in range(N)]    # N번째 집까지 들렸을 때 얻을 수 있는 돈의 최대값

    # 1. 1번 집을 들리는 경우
    dp1[0] = dp1[1] = money[0]  # 1-2번 집을 연속으로 들리지 못함
    for i in range(2, N-1):
        dp1[i] = max(dp1[i-1], dp1[i-2] + money[i])  # 이전집을 들렸을 때의 최대값 VS 현재의 집을 들리고 i-2번째 집까지의 최대값

    # 2. N번 집을 들리는 경우
    dp2[1], dp2[2] = money[1], max(money[1], money[2])  # 1번집은 무조건 못 들리고, 2번째와 세번째 집 중에 더 큰 돈이 있는 집을 선택
    for i in range(3, N):
        dp2[i] = max(dp2[i-1], dp2[i-2] + money[i])

    return max(dp1[-2], dp2[-1])  # 집이 원형 배치이기 때문에(1과 N은 둘다 선택 불가능) 끝점 혹은 시작점을 선택한 두 경우로 나눠서 더 큰 값을 구해애 함

print(solution([1, 2, 3, 1]))

